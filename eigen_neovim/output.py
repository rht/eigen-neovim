"""Output generators for eigen-neovim analysis results."""

from __future__ import annotations

from datetime import datetime
from pathlib import Path
from typing import TYPE_CHECKING

from .stats import AggregatedStats

if TYPE_CHECKING:
    from .plotting import PowerLawFit


def generate_markdown_report(
    stats: AggregatedStats, output_path: Path, power_law_fit: PowerLawFit | None = None
) -> None:
    """Generate a markdown report of the analysis."""
    lines = [
        "# Eigen-Neovim Analysis Results",
        "",
        f"Analysis of **{stats.total_configs}** Neovim Lua configurations.",
        "",
        f"Last updated: {datetime.now().strftime('%Y-%m-%d')}",
        "",
        "---",
        "",
        "## Most Common Options",
        "",
        "| Rank | Option | Usage |",
        "|------|--------|-------|",
    ]

    for i, opt in enumerate(stats.options[:50], 1):
        # Show most common value if not just true/false
        value_info = ""
        if opt.values:
            top_value, top_count = opt.values.most_common(1)[0]
            if top_value not in ("True", "true"):
                value_info = f" (commonly `{top_value}`)"
        lines.append(f"| {i} | `{opt.name}` | {opt.percentage:.1f}%{value_info} |")

    lines.extend(
        [
            "",
            "---",
            "",
            "## Most Popular Plugins",
            "",
            "| Rank | Plugin | Usage |",
            "|------|--------|-------|",
        ]
    )

    for i, plugin in enumerate(stats.plugins[:30], 1):
        lines.append(f"| {i} | `{plugin.name}` | {plugin.percentage:.1f}% |")

    lines.extend(
        [
            "",
            "---",
            "",
            "## Colorscheme Preferences",
            "",
        ]
    )

    if stats.colorschemes:
        lines.extend(
            [
                "| Rank | Colorscheme | Usage |",
                "|------|-------------|-------|",
            ]
        )
        for i, cs in enumerate(stats.colorschemes[:15], 1):
            lines.append(f"| {i} | `{cs.name}` | {cs.percentage:.1f}% |")
    else:
        lines.append("*No colorschemes detected (many configs load colorschemes via plugin setup)*")

    # Leader key statistics
    if stats.leader_keys:
        lines.extend(
            [
                "",
                "---",
                "",
                "## Leader Key Preferences",
                "",
            ]
        )
        total_leaders = sum(stats.leader_keys.values())
        for key, count in stats.leader_keys.most_common(5):
            pct = count * 100.0 / total_leaders
            display_key = key if key.strip() else "(space)"
            if key == " ":
                display_key = "Space"
            lines.append(f"- `{display_key}`: {pct:.1f}%")

    # Common keymaps
    if stats.keymaps:
        lines.extend(
            [
                "",
                "---",
                "",
                "## Common Keymaps",
                "",
                "| Mode | LHS | Usage |",
                "|------|-----|-------|",
            ]
        )
        for km in stats.keymaps[:20]:
            lines.append(f"| `{km.mode}` | `{km.lhs}` | {km.percentage:.1f}% |")

    # Power law distribution analysis
    if power_law_fit and power_law_fit.r_squared > 0:
        lines.extend(
            [
                "",
                "---",
                "",
                "## Distribution Analysis",
                "",
                "Power law fit for option usage: `y = c × x^(-α)`",
                "",
                f"- Coefficient (c): {power_law_fit.coefficient:.2f}",
                f"- Exponent (α): {power_law_fit.exponent:.2f}",
                f"- R² (goodness of fit): {power_law_fit.r_squared:.3f}",
                "",
                "![Distribution plot](fig.png)",
                "",
                "*Note: The original eigenvimrc (2017) found that option usage doesn't follow "
                "a pure power law distribution, likely because some settings are highly "
                "correlated with others.*",
            ]
        )

    # Metadata
    lines.extend(
        [
            "",
            "---",
            "",
            "## Metadata",
            "",
            f"- Total configurations analyzed: {stats.total_configs}",
            f"- Parse errors: {stats.parse_errors} ({stats.parse_errors * 100.0 / max(stats.total_configs, 1):.1f}%)",
            "",
            "---",
            "",
            "*Generated by [eigen-neovim](https://github.com/rht/eigenvimrc)*",
        ]
    )

    output_path.write_text("\n".join(lines), encoding="utf-8")


def generate_eigen_lua(
    stats: AggregatedStats, output_path: Path, threshold: float = 40.0, top_n: int = 30
) -> None:
    """Generate an eigen.lua file with the most common settings.

    Uses adaptive thresholding: if the fixed threshold yields no results,
    falls back to including top N options/plugins.
    """
    # Determine effective threshold - use adaptive if fixed threshold yields nothing
    options_above_threshold = [o for o in stats.options if o.percentage >= threshold]
    if not options_above_threshold and stats.options:
        # Fall back to top N options
        effective_threshold = stats.options[min(top_n, len(stats.options)) - 1].percentage
        threshold_note = f"Top {min(top_n, len(stats.options))} options (adaptive threshold: {effective_threshold:.1f}%+)"
    else:
        effective_threshold = threshold
        threshold_note = f"Settings appearing in {threshold:.0f}%+ of configs"

    lines = [
        "-- eigen.lua",
        "-- Community-consensus Neovim configuration",
        f"-- Based on analysis of {stats.total_configs} configurations",
        f"-- Generated: {datetime.now().strftime('%Y-%m-%d')}",
        f"-- {threshold_note}",
        "",
        "local M = {}",
        "",
        "function M.setup()",
        "  -- Leader key (set before lazy.nvim)",
    ]

    # Add leader key if available
    if stats.leader_keys:
        top_leader, _ = stats.leader_keys.most_common(1)[0]
        if top_leader == " ":
            lines.append('  vim.g.mapleader = " "')
            lines.append('  vim.g.maplocalleader = " "')
        else:
            lines.append(f'  vim.g.mapleader = "{top_leader}"')

    lines.append("")
    lines.append("  -- Options")

    # Add options that meet the threshold (or top N)
    options_added = 0
    for opt in stats.options:
        if opt.percentage >= effective_threshold or options_added < top_n:
            # Skip leader keys (handled above) and internal options
            if opt.name in (
                "mapleader",
                "maplocalleader",
                "loaded_netrw",
                "loaded_netrwPlugin",
                "base46_cache",
                "have_nerd_font",
            ):
                continue
            # Determine the most common value
            if opt.values:
                top_value, _ = opt.values.most_common(1)[0]
                # Format the value appropriately
                if top_value in ("True", "true"):
                    val = "true"
                elif top_value in ("False", "false"):
                    val = "false"
                elif top_value.isdigit():
                    val = top_value
                elif top_value.startswith("{") or top_value.startswith("vim."):
                    val = top_value  # Keep tables/vim expressions as-is
                else:
                    # Escape quotes in string values
                    val = f'"{top_value}"'
                lines.append(f"  vim.opt.{opt.name} = {val}  -- {opt.percentage:.1f}%")
                options_added += 1
        else:
            break

    lines.extend(
        [
            "end",
            "",
            "-- Popular plugins (for reference)",
            "M.recommended_plugins = {",
        ]
    )

    # Add top plugins (use adaptive threshold too)
    plugin_threshold = 1.0  # Lower default for plugins
    plugins_added = 0
    for plugin in stats.plugins[:30]:
        if plugin.percentage >= plugin_threshold or plugins_added < 20:
            lines.append(f'  "{plugin.name}",  -- {plugin.percentage:.1f}%')
            plugins_added += 1

    lines.extend(
        [
            "}",
            "",
            "-- Popular colorschemes",
            "M.colorschemes = {",
        ]
    )

    # Add top colorschemes
    for cs in stats.colorschemes[:10]:
        lines.append(f'  "{cs.name}",  -- {cs.percentage:.1f}%')

    lines.extend(
        [
            "}",
            "",
            "return M",
        ]
    )

    output_path.write_text("\n".join(lines), encoding="utf-8")


def generate_lazy_plugin_spec(stats: AggregatedStats, output_path: Path) -> None:
    """Generate a lazy.nvim plugin spec with popular plugins."""
    lines = [
        "-- Popular plugins for lazy.nvim",
        f"-- Based on analysis of {stats.total_configs} configurations",
        f"-- Generated: {datetime.now().strftime('%Y-%m-%d')}",
        "",
        "return {",
    ]

    for plugin in stats.plugins[:30]:
        if plugin.percentage >= 5.0:
            lines.append(f'  {{ "{plugin.name}" }},  -- {plugin.percentage:.1f}%')

    lines.append("}")

    output_path.write_text("\n".join(lines), encoding="utf-8")
